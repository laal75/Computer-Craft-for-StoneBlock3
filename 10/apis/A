-- This library provide high level turtle movement functions.
--
-- Before being able to use them, you should start the GPS with egps.startGPS()
--    then get your current location with egps.setLocationFromGPS().
-- egps.forward(), egps.back(), egps.up(), egps.down(), egps.turnLeft(), egps.turnRight()
--    replace the standard turtle functions. 
-- If you need to use the standard functions, you
--    should call egps.setLocationFromGPS() again before using any egps functions.

-- Added per user request:
local DEBUG = true
local function dprint(msg)
    if DEBUG then print("[A DEBUG] "..msg) end
end

function empty(table)
  for _, value in pairs(table) do
    if value ~= nil then
      return false
    end
  end
  return true
end

-- Cache of the current turtle position and direction
local cachedX, cachedY, cachedZ, cachedDir

-- Directions
North, West, South, East, Up, Down = 0, 1, 2, 3, 4, 5
local shortNames = {
    [North] = "N", [West] = "W", [South] = "S",
    [East] = "E", [Up] = "U", [Down] = "D"
}

local deltas = {
    [North] = {0, 0, -1},
    [West]  = {-1, 0, 0},
    [South] = {0, 0, 1},
    [East]  = {1, 0, 0},
    [Up]    = {0, 1, 0},
    [Down]  = {0, -1, 0}
}

-- cache world geometry
local cachedWorld = {}

-- A* parameters
local stopAt, nilCost = 1500, 1000

local function ensureDir()
  if cachedDir == nil or deltas[cachedDir] == nil then
    dprint("ensureDir(): cachedDir invalid ("..tostring(cachedDir).."), forcing North")
    cachedDir = North
  end
end

----------------------------------------
-- detectAll
----------------------------------------
function detectAll()
  -- keep the old guard, but now we also have ensureDir() elsewhere
  if cachedDir == nil then
    dprint("detectAll() fallback: cachedDir=nil, forcing North")
    cachedDir = North
  end

  dprint("detectAll(): at ("..
        tostring(cachedX)..","..
        tostring(cachedY)..","..
        tostring(cachedZ)..") dir="..tostring(cachedDir))

  local F, U, D = deltas[cachedDir], deltas[Up], deltas[Down]

  cachedWorld[cachedX..":"..cachedY..":"..cachedZ] = 0

  if not turtle.detect() then
    cachedWorld[(cachedX + F[1])..":"..(cachedY + F[2])..":"..(cachedZ + F[3])] = 0
  end
  if not turtle.detectUp() then
    cachedWorld[(cachedX + U[1])..":"..(cachedY + U[2])..":"..(cachedZ + U[3])] = 0
  end
  if not turtle.detectDown() then
    cachedWorld[(cachedX + D[1])..":"..(cachedY + D[2])..":"..(cachedZ + D[3])] = 0
  end
end

----------------------------------------
-- forward
----------------------------------------
function forward()
  ensureDir()
  local D = deltas[cachedDir]
  local x, y, z = cachedX + D[1], cachedY + D[2], cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z

  if turtle.forward() then
    cachedX, cachedY, cachedZ = x, y, z
    detectAll()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detect() and 1 or 0.5)
    return false
  end
end

----------------------------------------
-- back
----------------------------------------
function back()
  ensureDir()
  local D = deltas[cachedDir]
  local x, y, z = cachedX - D[1], cachedY - D[2], cachedZ - D[3]
  local idx_pos = x..":"..y..":"..z

  if turtle.back() then
    cachedX, cachedY, cachedZ = x, y, z
    detectAll()
    return true
  else
    cachedWorld[idx_pos] = 0.5
    return false
  end
end

----------------------------------------
-- up
----------------------------------------
function up()
  local D = deltas[Up]
  local x, y, z = cachedX + D[1], cachedY + D[2], cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z

  if turtle.up() then
    cachedX, cachedY, cachedZ = x, y, z
    detectAll()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detectUp() and 1 or 0.5)
    return false
  end
end

----------------------------------------
-- down
----------------------------------------
function down()
  local D = deltas[Down]
  local x, y, z = cachedX + D[1], cachedY + D[2], cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z

  if turtle.down() then
    cachedX, cachedY, cachedZ = x, y, z
    detectAll()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detectDown() and 1 or 0.5)
    return false
  end
end

----------------------------------------
-- turnLeft
----------------------------------------
function turnLeft()
  ensureDir()
  cachedDir = (cachedDir + 1) % 4
  turtle.turnLeft()
  detectAll()
  return true
end

----------------------------------------
-- turnRight
----------------------------------------
function turnRight()
  ensureDir()
  cachedDir = (cachedDir + 3) % 4
  turtle.turnRight()
  detectAll()
  return true
end

----------------------------------------
-- turnTo
----------------------------------------
function turnTo(_targetDir)
  ensureDir()
  if _targetDir == cachedDir then
    return true
  elseif ((_targetDir - cachedDir + 4) % 4) == 1 then
    turnLeft()
  elseif ((cachedDir - _targetDir + 4) % 4) == 1 then
    turnRight()
  else
    turnLeft()
    turnLeft()
  end
  return true
end

----------------------------------------
-- clearWorld
----------------------------------------
function clearWorld()
  cachedWorld = {}
  detectAll()
end

----------------------------------------
-- A* helpers (unchanged)
----------------------------------------
local function heuristic_cost_estimate(x1, y1, z1, x2, y2, z2)
  return math.abs(x2 - x1) + math.abs(z2 - z1) + math.abs(y2 - y1)
end

local function reconstruct_path(_cameFrom, _currentNode)
  if _cameFrom[_currentNode] ~= nil then
    local dir, nextNode = _cameFrom[_currentNode][1], _cameFrom[_currentNode][2]
    local path = reconstruct_path(_cameFrom, nextNode)
    table.insert(path, dir)
    return path
  else
    return {}
  end
end

local function a_star(x1, y1, z1, x2, y2, z2, discover)
  discover = discover or 1
  local start, idx_start = {x1, y1, z1}, x1..":"..y1..":"..z1
  local goal,  idx_goal  = {x2, y2, z2}, x2..":"..y2..":"..z2

  if (cachedWorld[idx_goal] or 0) == 0 then
    local openset, closedset, cameFrom, g_score, f_score = {}, {}, {}, {}, {}

    openset[idx_start] = start
    g_score[idx_start] = 0
    f_score[idx_start] = heuristic_cost_estimate(x1, y1, z1, x2, y2, z2)

    while not empty(openset) do
      local current, idx_current
      local cur_f = 9999999

      for idx_cur, cur in pairs(openset) do
        if cur ~= nil and f_score[idx_cur] <= cur_f then
          idx_current, current, cur_f = idx_cur, cur, f_score[idx_cur]
        end
      end
      if idx_current == idx_goal then
        return reconstruct_path(cameFrom, idx_goal)
      end

      if cur_f >= stopAt then break end

      openset[idx_current] = nil
      closedset[idx_current] = true

      local x3, y3, z3 = current[1], current[2], current[3]

      for dir = 0, 5 do
        local D = deltas[dir]
        local x4, y4, z4 = x3 + D[1], y3 + D[2], z3 + D[3]
        local neighbor, idx_neighbor = {x4, y4, z4}, x4..":"..y4..":"..z4
        if (cachedWorld[idx_neighbor] or 0) == 0 then
          if closedset[idx_neighbor] == nil then
            local tentative_g_score = g_score[idx_current] +
               ((cachedWorld[idx_neighbor] == nil) and discover or 1)
            if openset[idx_neighbor] == nil or tentative_g_score <= g_score[idx_neighbor] then
              cameFrom[idx_neighbor] = {dir, idx_current}
              g_score[idx_neighbor] = tentative_g_score
              f_score[idx_neighbor] = tentative_g_score +
                   heuristic_cost_estimate(x4, y4, z4, x2, y2, z2)
              openset[idx_neighbor] = neighbor
            end
          end
        end
      end
    end
  end
  print("no path found")
  return {}
end

----------------------------------------
-- moveTo
----------------------------------------
function moveTo(_targetX, _targetY, _targetZ, _targetDir, changeDir, discover)
  changeDir = (changeDir == nil) and true or changeDir

  while cachedX ~= _targetX or cachedY ~= _targetY or cachedZ ~= _targetZ do
    local path = a_star(cachedX, cachedY, cachedZ, _targetX, _targetY, _targetZ, discover)
    if #path == 0 then
      return false
    end

    for i, dir in ipairs(path) do
      if dir == Up then
        if not up() then break end
      elseif dir == Down then
        if not down() then break end
      else
        turnTo(dir)
        if not forward() then break end
      end
    end
  end

  if changeDir then
    turnTo(_targetDir)
  end
  return true
end

----------------------------------------
-- discoverWorld (unchanged)
----------------------------------------
function discoverWorld(_range)
  local x, y, z, d = gps.locate()

  for r = 1, _range do
    for dx = -r, r do
      for dy = -r, r do
        for dz = -r, r do
          local idx_goal = (x+dx)..":"..(y+dy)..":"..(z+dz)
          if cachedWorld[idx_goal] == nil then
            moveTo(x+dx, y+dy, z+dz, cachedDir, false, nilCost)
            sleep(0.01)
          end
        end
      end
    end
  end

  moveTo(x, y, z, d)
end

----------------------------------------
-- setLocation
----------------------------------------
function setLocation(x, y, z, d)
  cachedX, cachedY, cachedZ, cachedDir = x, y, z, d
  return cachedX, cachedY, cachedZ, cachedDir
end

----------------------------------------
-- startGPS
----------------------------------------
function startGPS()
  local netOpen, modemSide = false, nil

  for _, side in pairs(rs.getSides()) do
    if peripheral.getType(side) == "modem" then
      modemSide = side
      if rednet.isOpen(side) then
        netOpen = true
        break
      end
    end
  end

  if not netOpen then
    if modemSide then
      rednet.open(modemSide)
    else
      print("No modem found")
      return false
    end
  end
  return true
end

----------------------------------------
-- setLocationFromGPS
----------------------------------------
function setLocationFromGPS()
  if startGPS() then
    cachedX, cachedY, cachedZ  = gps.locate(4, false)
    cachedDir = nil

    for tries = 0, 3 do
      if turtle.forward() then
        local newX, _, newZ = gps.locate(4, false)
        turtle.back()

        if newZ < cachedZ then
          cachedDir = North
        elseif newZ > cachedZ then
          cachedDir = South
        elseif newX < cachedX then
          cachedDir = West
        elseif newX > cachedX then
          cachedDir = East
        end

        turnTo((cachedDir - tries + 4) % 4)
        break
      else
        tries = tries + 1
        turtle.turnLeft()
      end
    end

    if cachedDir == nil then
      print("Could not determine direction")
      ensureDir()
    end

    return cachedX, cachedY, cachedZ, cachedDir
  end
end

----------------------------------------
-- getLocation
----------------------------------------
function getLocation()
  return cachedX, cachedY, cachedZ, cachedDir
end
