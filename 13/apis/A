-- This library provide high level turtle movement functions.
--
-- Before being able to use them, you should start the GPS with egps.startGPS()
--    then get your current location with egps.setLocationFromGPS().
-- egps.forward(), egps.back(), egps.up(), egps.down(), egps.turnLeft(), egps.turnRight()
--    replace the standard turtle functions. 
-- If you need to use the standard functions, you
--    should call egps.setLocationFromGPS() again before using any egps functions.

-- Gist at: https://gist.github.com/SquidLord/4741746

-- The MIT License (MIT)

-- Copyright (c) 2012 Alexander Williams

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

function empty(table)
  for _, value in pairs(table) do
    if value ~= nil then
          return false
    end
  end
  return true
end

-- Cache of the current turtle position and direction
-- Use global A table for all state
A = A or {}
A.cachedX, A.cachedY, A.cachedZ, A.cachedDir = nil, nil, nil, nil
-- ==========================
-- DEBUG SWITCH
-- ==========================
local DEBUG = false -- Set to true to enable debug logs
local comp3ID = 3
local modemSide = "right"

if not rednet.isOpen and peripheral and peripheral.getType then
  for _, side in ipairs({"left","right","top","bottom","front","back"}) do
    if peripheral.getType(side) == "modem" then
      modemSide = side
      if rednet and not rednet.isOpen(side) then pcall(function() rednet.open(side) end) end
      break
    end
  end
end

local function dlog(msg)
  if DEBUG == true then
    local line = "[A-DBG] " .. tostring(msg)
    print(line)
    if rednet and comp3ID then
      local packet = { log = line, src = "A", time = os.date("%H:%M:%S") }
      pcall(function() rednet.send(comp3ID, packet, "DRAWIE_STATUS") end)
    end
  end
end

A = A or {}
local function updatePos()
  -- Ensure field order: x, y, z, dir
  A.pos = { x = A.cachedX, y = A.cachedY, z = A.cachedZ, dir = A.cachedDir }
end

-- Directions
North, West, South, East, Up, Down = 0, 1, 2, 3, 4, 5
local shortNames = {[North] = "N", [West] = "W", [South] = "S",
                                    [East] = "E", [Up] = "U", [Down] = "D" }
local deltas = {[North] = {0, 0, -1}, [West] = {-1, 0, 0}, [South] = {0, 0, 1},
                            [East] = {1, 0, 0}, [Up] = {0, 1, 0}, [Down] = {0, -1, 0}}

-- cache world geometry
local cachedWorld = {}

-- A* parameters
local stopAt, nilCost = 1500, 1000

----------------------------------------
-- detectAll
--
-- function: Detect in all possible directions
--

function detectAll()
  local F, U, D = deltas[A.cachedDir], deltas[Up], deltas[Down]
  cachedWorld[(A.cachedX or 0)..":"..(A.cachedY or 0)..":"..(A.cachedZ or 0)] = 0
  if not turtle.detect()         then cachedWorld[((A.cachedX or 0) + F[1])..":"..((A.cachedY or 0) + F[2])..":"..((A.cachedZ or 0) + F[3])] = 0 end
  if not turtle.detectUp()   then cachedWorld[((A.cachedX or 0) + U[1])..":"..((A.cachedY or 0) + U[2])..":"..((A.cachedZ or 0) + U[3])] = 0 end
  if not turtle.detectDown() then cachedWorld[((A.cachedX or 0) + D[1])..":"..((A.cachedY or 0) + D[2])..":"..((A.cachedZ or 0) + D[3])] = 0 end
  updatePos()
end
 
----------------------------------------
-- forward
--
-- function: Move the turtle forward if possible and put the result in cache
-- return: boolean "success"
--
function forward()
  dlog(string.format("forward() called at (%s,%s,%s) dir=%s", tostring(A.cachedX), tostring(A.cachedY), tostring(A.cachedZ), tostring(A.cachedDir)))
  local D = deltas[A.cachedDir]
  local x, y, z = A.cachedX + D[1], A.cachedY + D[2], A.cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z
  if turtle.forward() then
    A.cachedX, A.cachedY, A.cachedZ = x, y, z
    detectAll()
    updatePos()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detect() and 1 or 0.5)
    updatePos()
    return false
  end
end

----------------------------------------
-- back
--
-- function: Move the turtle backward if possible and put the result in cache
-- return: boolean "success"
--

function back()
  dlog(string.format("back() called at (%s,%s,%s) dir=%s", tostring(A.cachedX), tostring(A.cachedY), tostring(A.cachedZ), tostring(A.cachedDir)))
  local D = deltas[A.cachedDir]
  local x, y, z = A.cachedX - D[1], A.cachedY - D[2], A.cachedZ - D[3]
  local idx_pos = x..":"..y..":"..z
  if turtle.back() then
    A.cachedX, A.cachedY, A.cachedZ = x, y, z
    detectAll()
    updatePos()
    return true
  else
    cachedWorld[idx_pos] = 0.5
    updatePos()
    return false
  end
end

----------------------------------------
-- up
--
-- function: Move the turtle up if possible and put the result in cache
-- return: boolean "success"
--

function up()
  dlog(string.format("up() called at (%s,%s,%s) dir=%s", tostring(A.cachedX), tostring(A.cachedY), tostring(A.cachedZ), tostring(A.cachedDir)))
  local D = deltas[Up]
  local x, y, z = A.cachedX + D[1], A.cachedY + D[2], A.cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z
  if turtle.up() then
    A.cachedX, A.cachedY, A.cachedZ = x, y, z
    detectAll()
    updatePos()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detectUp() and 1 or 0.5)
    updatePos()
    return false
  end
end

----------------------------------------
-- down
--
-- function: Move the turtle down if possible and put the result in cache
-- return: boolean "success"
--

function down()
  dlog(string.format("down() called at (%s,%s,%s) dir=%s", tostring(A.cachedX), tostring(A.cachedY), tostring(A.cachedZ), tostring(A.cachedDir)))
  local D = deltas[Down]
  local x, y, z = A.cachedX + D[1], A.cachedY + D[2], A.cachedZ + D[3]
  local idx_pos = x..":"..y..":"..z
  if turtle.down() then
    A.cachedX, A.cachedY, A.cachedZ = x, y, z
    detectAll()
    updatePos()
    return true
  else
    cachedWorld[idx_pos] = (turtle.detectDown() and 1 or 0.5)
    updatePos()
    return false
  end
end

----------------------------------------
-- turnLeft
--
-- function: Turn the turtle to the left and put the result in cache
-- return: boolean "success"
--

function turnLeft()
  dlog(string.format("turnLeft() called at dir=%s", tostring(A.cachedDir)))
  A.cachedDir = (A.cachedDir + 1) % 4
  turtle.turnLeft()
  detectAll()
  updatePos()
  return true
end

----------------------------------------
-- turnRight
--
-- function: Turn the turtle to the right and put the result in cache
-- return: boolean "success"
--

function turnRight()
  dlog(string.format("turnRight() called at dir=%s", tostring(A.cachedDir)))
  A.cachedDir = (A.cachedDir + 3) % 4
  turtle.turnRight()
  detectAll()
  updatePos()
  return true
end

----------------------------------------
-- turnTo
--
-- function: Turn the turtle to the choosen direction and put the result in cache
-- input: number _targetDir
-- return: boolean "success"
--

function turnTo(_targetDir)
  if A.cachedDir == nil then
    print("[A] WARNING: cachedDir was nil in turnTo, defaulting to East (3)")
    A.cachedDir = 3
    updatePos()
  end
  dlog(string.format("turnTo(%s) from dir=%s", tostring(_targetDir), tostring(A.cachedDir)))
  if _targetDir == A.cachedDir then
    updatePos()
    return true
  elseif ((_targetDir - A.cachedDir + 4) % 4) == 1 then
    turnLeft()
  elseif ((A.cachedDir - _targetDir + 4) % 4) == 1 then
    turnRight()
  else
    turnLeft()
    turnLeft()
  end
  updatePos()
  return true
end

----------------------------------------
-- clearWorld
--
-- function: Clear the world cache
--

function clearWorld()
  cachedWorld = {}
  detectAll()
end

----------------------------------------
-- heuristic_cost_estimate
--
-- function: A* heuristic
-- input: X, Y, Z of the 2 points
-- return: Manhattan distance between the 2 points
--

local function heuristic_cost_estimate(x1, y1, z1, x2, y2, z2)
  return math.abs(x2 - x1) + math.abs(y2 - y1) + math.abs(z2 - z1)
end

----------------------------------------
-- reconstruct_path
--
-- function: A* path reconstruction
-- input: A* visited nodes and goal
-- return: List of movement to be executed
--

local function reconstruct_path(_cameFrom, _currentNode)
  if _cameFrom[_currentNode] ~= nil then
    local dir, nextNode = _cameFrom[_currentNode][1], _cameFrom[_currentNode][2]
    local path = reconstruct_path(_cameFrom, nextNode)
    table.insert(path, dir)
    return path
  else
    return {}
  end
end

----------------------------------------
-- a_star
--
-- function: A* path finding
-- input: start and goal coordinates
-- return: List of movement to be executed
--

local function a_star(x1, y1, z1, x2, y2, z2, discover)
  -- Defensive: default to 0 if any are nil
  x1 = x1 or 0; y1 = y1 or 0; z1 = z1 or 0
  x2 = x2 or 0; y2 = y2 or 0; z2 = z2 or 0
  discover = discover or 1
  local start, idx_start = {x1, y1, z1}, x1..":"..y1..":"..z1
  local goal,  idx_goal  = {x2, y2, z2}, x2..":"..y2..":"..z2

  if (cachedWorld[idx_goal] or 0) == 0 then
    local openset, closedset, cameFrom, g_score, f_score, tries = {}, {}, {}, {}, {}, 0

    openset[idx_start] = start
    g_score[idx_start] = 0
    f_score[idx_start] = heuristic_cost_estimate(x1, y1, z1, x2, y2, z2)

    while not empty(openset) do
          local current, idx_current
          local cur_f = 9999999
            
          for idx_cur, cur in pairs(openset) do
            if cur ~= nil and f_score[idx_cur] <= cur_f then
                  idx_current, current, cur_f = idx_cur, cur, f_score[idx_cur]
            end
          end
          if idx_current == idx_goal then
            return reconstruct_path(cameFrom, idx_goal)
          end

          -- no more than 500 moves
          if cur_f >= stopAt then
            break
          end
            
          openset[idx_current] = nil
          closedset[idx_current] = true
            
          local x3, y3, z3 = current[1], current[2], current[3]

          for dir = 0, 5 do -- for all direction find the neighbor of the current position
            local D = deltas[dir]
            local x4, y4, z4 = x3 + D[1], y3 + D[2], z3 + D[3]
            local neighbor, idx_neighbor = {x4, y4, z4}, x4..":"..y4..":"..z4
            if (cachedWorld[idx_neighbor] or 0) == 0 then -- if its free or unknow
                  if closedset[idx_neighbor] == nil then
                    local tentative_g_score = g_score[idx_current] + ((cachedWorld[idx_neighbor] == nil) and discover or 1)
                    if openset[idx_neighbor] == nil or tentative_g_score <= g_score[idx_neighbor] then
                          cameFrom[idx_neighbor] = {dir, idx_current}
                          g_score[idx_neighbor] = tentative_g_score
                          f_score[idx_neighbor] = tentative_g_score + heuristic_cost_estimate(x4, y4, z4, x2, y2, z2)
                          openset[idx_neighbor] = neighbor
                    end
                  end
            end
          end
    end
  end
  print("no path found")
  return {}
end

----------------------------------------
-- moveTo
--
-- function: Move the turtle to the choosen coordinates in the world
-- input: X, Y, Z and direction of the goal
-- return: boolean "success"
--

function moveTo(_targetX, _targetY, _targetZ, _targetDir, changeDir, discover)
  changeDir = (changeDir == nil) and true or changeDir
  local stuckCount = 0
  local lastX, lastY, lastZ = A.cachedX, A.cachedY, A.cachedZ
  while A.cachedX ~= _targetX or A.cachedY ~= _targetY or A.cachedZ ~= _targetZ do
    local path = a_star(A.cachedX, A.cachedY, A.cachedZ, _targetX, _targetY, _targetZ, discover)
    if #path == 0 then
      dlog("[A] moveTo: No path found to target, aborting.")
      return false
    end
    local progress = false
    for i, dir in ipairs(path) do
      if dir == Up then
        if up() then progress = true else break end
      elseif dir == Down then
        if down() then progress = true else break end
      else
        turnTo(dir)
        if forward() then progress = true else break end
      end
    end
    if not progress then
      stuckCount = stuckCount + 1
      dlog("[A] moveTo: No progress made, stuckCount="..stuckCount)
      if stuckCount >= 20 then
        dlog("[A] moveTo: Stuck for 20 attempts, aborting to prevent infinite loop.")
        return false
      end
    else
      stuckCount = 0
    end
    -- Defensive: break if we are stuck at the same position for too long
    if A.cachedX == lastX and A.cachedY == lastY and A.cachedZ == lastZ then
      stuckCount = stuckCount + 1
      if stuckCount >= 20 then
        dlog("[A] moveTo: Stuck at same position for 20 attempts, aborting.")
        return false
      end
    else
      lastX, lastY, lastZ = A.cachedX, A.cachedY, A.cachedZ
      stuckCount = 0
    end
  end
  if changeDir then
    turnTo(_targetDir)
  end
  return true
end

----------------------------------------
-- discoverWorld
--
-- function: Move the turtle to the choosen coordinates in the world
-- input: size of the cuboid to check
--

function discoverWorld(_range)
  local x, y, z, d = locate()
 
  -- Try to go to every location in the cuboid
  for r = 1, _range do
    for dx = -r, r do
          for dy = -r, r do
            for dz = -r, r do
                  local idx_goal = (x+dx)..":"..(y+dy)..":"..(z+dz)
                  if cachedWorld[idx_goal] == nil then
                    moveTo(x+dx, y+dy, z+dz, cachedDir, false, nilCost)
                    sleep(0.01)
                  end
            end
          end
    end
  end

  -- Go back to the starting point  
  moveTo(x, y, z, d)
end

----------------------------------------
-- setLocation
--
-- function: Set the current X, Y, Z and direction of the turtle
--

function setLocation(x, y, z, d)
  dlog(string.format("setLocation(%s,%s,%s,%s)", tostring(x), tostring(y), tostring(z), tostring(d)))
  A.cachedX, A.cachedY, A.cachedZ, A.cachedDir = x, y, z, d
  updatePos()
  return A.cachedX, A.cachedY, A.cachedZ, A.cachedDir
end

----------------------------------------
-- startGPS
--
-- function: Open the rednet network
-- return: boolean "success"
--

function startGPS()
    local netOpen, modemSide = false, nil
 
    for _, side in pairs(rs.getSides()) do    -- for all sides
        if peripheral.getType(side) == "modem" then  -- find the modem
            modemSide = side
            if rednet.isOpen(side) then  -- check its status
                netOpen = true
                break
            end
        end
    end

    if not netOpen then  -- if the rednet network is not open
        if modemSide then  -- and we found a modem, open the rednet network
            rednet.open(modemSide)
        else
            print("No modem found")
            return false
        end
    end
    return true
end

----------------------------------------
-- setGPSLocation
--
-- function: Retrieve the turtle GPS position and direction (if possible)
-- return: current X, Y, Z and direction of the turtle
--

function setLocationFromGPS()
  dlog("setLocationFromGPS() called")
  if startGPS() then
    -- get the current position
    A.cachedX, A.cachedY, A.cachedZ  = gps.locate(4, false)
    A.cachedDir = nil

    -- determine the current direction
    for tries = 0, 3 do  -- try to move in one direction
      if turtle.forward() then
        local newX, _, newZ = gps.locate(4, false) -- get the new position
        turtle.back() -- and go back

        -- deduce the curent direction
        if newZ < A.cachedZ then
          A.cachedDir = North -- North
        elseif newZ > A.cachedZ then
          A.cachedDir = South -- South
        elseif newX < A.cachedX then
          A.cachedDir = West -- West
        elseif newX > A.cachedX then
          A.cachedDir = East -- East
        end

        -- Cancel out the tries
        if A.cachedDir ~= nil then
          turnTo((A.cachedDir - tries + 4) % 4)
        end

        -- exit the loop
        break
      else -- try in another direction
        tries = tries + 1
        turtle.turnLeft()
      end
    end

    if A.cachedDir == nil then
      dlog("[A] Could not determine direction, defaulting to East (3)")
      A.cachedDir = 3
    end

    updatePos()
    dlog(string.format("setLocationFromGPS() -> cachedX=%s, cachedY=%s, cachedZ=%s, cachedDir=%s", tostring(A.cachedX), tostring(A.cachedY), tostring(A.cachedZ), tostring(A.cachedDir)))
    if A.pos and type(A.pos) == "table" then
      dlog(string.format("A.pos after GPS: { x = %s, y = %s, z = %s, dir = %s }",
        tostring(A.pos.x), tostring(A.pos.y), tostring(A.pos.z), tostring(A.pos.dir)))
    else
      dlog("A.pos after GPS: nil or not a table")
    end
    -- Return the current turtle position
    return A.cachedX, A.cachedY, A.cachedZ, A.cachedDir
  end
end

----------------------------------------
-- getLocation
--
-- function: Retrieve the cached turtle position and direction
-- return: cached X, Y, Z and direction of the turtle
--

function getLocation()
  updatePos()
  return A.cachedX, A.cachedY, A.cachedZ, A.cachedDir
end